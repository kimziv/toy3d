#summary 基础数据结构的设计


=指针数组=



==基本原则==
 * 数组元素是指针
 * 数组长度可动态增加
 * 支持各种数据类型，类似C++模板。


==动态变化策略==
数组增长：
当已分配长度不够时，重新分配内存，按照如下原则(假设需求长度为n，实际分配长度为x)：
2^x >= n，其中x取可取的最小整数。


==几个需要考虑的问题==

 * 插入元素时，索引越界的情况怎样处理？此处的越界是指不按照顺序处理数组元素，索引出现跳跃。即如下情况：
   mPtrArray[0] = ...;
   insert(..., 3);

   解决：中间的值设置为空值NULL，就上述例子来说，执行完第二句，将出现如下结果：
   mPtrArray[1] 值为 NULL;
   mPtrArray[2] 值为 NULL;
   mPtrArray.length 值为 4.

 * 删除时如何释放指针里的数据，glib 里要自己设置 set_clear_fun 函数。
   即：任何类型都是当作void *来删除的，如果某类型中含有指针，该指针对应的内存怎样释放？
   解决：按照目前的设计方案，涉及资源分配释放的都是对应的Manager类，这些类里都提供了destroy函数，在该函数中先释放掉该类本身的指针，再调用mPtrArray.destroy()即可。详见“用户使用”部分。


==类==

{{{
typedef void* TPointer;

class TPtrArray {
    protected: 
        TPointer *mPtr;  /* the pointer array data */
        Uint mLength;    /* the actual number of elements in the array */
        Uint mAllocLen;  /* the capacity, that is the number of elements, of the array */

    public:
        TPtrArray();
        ~TPtrArray();

        //create 
        void create(); 
        void create(Uint size); 
        
        //delete 
        Bool remove(TPointer ptr); 
        TPointer* removeByIndex(Uint index); 
        void destroy(); 
        
        //process 
        Bool insert(TPointer ptr, Uint index); 
        Bool append(TPointer ptr); 
        void setSize(Uint length); 
        
        TPointer getElement(Uint index); 
        Uint getLength(); 
        Uint getAllocLength(); 
        
        //override operator[], and operator= 
        const TPtrArray& operator[](Uint index);
        const TPtrArray& operator=(TPointer *mPtr);

    private: 
        void maybeExpand(Uint length);
};

}}}


==用户使用==

{{{

    //Sample code for Toy3DPtrArray
    //take MeshManager as example

    class MeshManager
    {
    private:
        MeshManager();
        static MeshManager* mInstance;

        TPtrArray mPtrArray;

    public:
        ~MeshManager();
        static MeshManager* getInstance();

        Mesh* createMesh();

        //void destroyMesh(Mesh *mesh);
        void destroyAllMeshes();
    };

    MeshManager::MeshManager()
    {
        mPtrArray.create();
    }

    MeshManager::~MeshManager()
    {
    }

    MeshManager* MeshManager::getInstance() 
    {
        if(NULL==mInstance)
            mInstance = new MeshManager();

        return mInstance;
    }

    Mesh* MeshManager::createMesh()
    {
        Mesh *pMesh = new Mesh();
        if( !pMesh )
            return NULL;

        mPtrArray.append((TPointer)pMesh );
        //or
        //mPtrArray[mPtrArray.getLength()] = pMesh;
        //or
        //mPtrArray.insert((TPointer)pMesh, mPtrArray.getLength());

        return pMesh;
    }

    void MeshManager::destroyAllMeshes()
    {
        Mesh *temp;

        while(length--)
        {
            temp = (Mesh *)mPtrArray->removeByIndex(length);
            delete temp;
        }

        mPtrArray->destroy();

        return;
    }

}}}

= Reference =

 * [http://developer.gnome.org/glib/2.34/ glib Manual]