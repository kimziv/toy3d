#summary 基础数据结构的设计


=指针数组=


==基本原则==
 * 数组元素是指针
 * 数组长度可动态增加
 * 支持各种数据类型，类似C++模板。


==动态变化策略==
数组增长：
当已分配长度不够时，重新分配内存，按照如下原则(假设需求长度为n，实际分配长度为x)：
2^x >= n，其中x取可取的最小整数。


==类==

{{{
typedef void* TPointer;

class Toy3DPtrArray {

protected:
    TPointer *pData;
    Uint len; //数组中元素个数
    Uint allocLen;//最大允许元素个数

public:
    Toy3DPtrArrar();

    //create
    void createPtrArray();
    void createPtrArray(Uint size);

    //delete
    Bool remove(TPointer pData);
    TOY3D_PTR* removeByIndex(Uint index);
    void destroyPtrArray();

    //process
    Bool insert(TPointer pData, Uint index);
    Bool append(TPointer pData);
    void setSize(Uint length);

    TOY3D_PTR getElement(Uint index);
    Uint getLength();
    Uint getAllocLength();

    //override operator [],=
    const Toy3DPtrArray& operator[]();
    const Toy3DPtrArray& operator=();
private:
    void maybeExpand(Uint length);
};
//遗留问题：
//1.插入元素时，
//mPtrArray[1] = ...;
//insert(...);
//如果索引跨过数组实际索引，中间的空值怎样处理？

}}}


==用户使用==

{{{

    //Sample code for Toy3DPtrArray
    //take Mesh as example;
    Bool rv;
    Uint size = 16;
    Mesh *mesh = new Mesh();
    Toy3DPtrArray mPtrArray;
    mPtrArray.createPtrArray();
    rv = mPtrArray.append((TPointer)mesh );
    if(!rv)
    {
        printf("append ptr element error.\n");
        return;
    }

    mesh = new Mesh();
    mPtrArray[1] = mesh;

    mesh = new Mesh();
    mPtrArray.insert(mesh, 2);

    mPtrArray.setSize(size);
    ...

    Mesh *mesh = (Mesh *)getElement(0);
    //Mesh *mesh = mPtrArray[0];
    mPtrArray.destroyPtrArray();

}}}

= Reference =

 * [http://developer.gnome.org/glib/2.34/ glib Manual]