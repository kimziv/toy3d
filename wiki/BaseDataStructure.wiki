#summary 基础数据结构的设计


=指针数组=


==基本原则==
 * 数组元素是指针
 * 数组长度可动态增加
 * 支持各种数据类型，类似C++模板。


==动态变化策略==
数组增长：
当已分配长度不够时，重新分配内存，按照如下原则(假设需求长度为n，实际分配长度为x)：
2^x >= n.


==类==

{{{
typedef void* TOY3D_PTR;

class Toy3DPtrArray {

protected:
    TOY3D_PTR *pData;
    Uint len; //数组中元素个数
    Uint allocLen;//最大允许元素个数

public:
    //create
    void createPtrArray();
    void createPtrArray(Uint size);

    //delete
    Bool remove(TOY3D_PTR pData);
    TOY3D_PTR* removeByIndex(Uint index);
    void destroyPtrArray();

    //process
    Bool insert(TOY3D_PTR pData, Uint index);
    Bool append(TOY3D_PTR pData);
    void setSize(Uint length);

    TOY3D_PTR getElement(Uint index);
    Uint getLength();
    Uint getAllocLength();

    //override operator []、=

private:
    void maybeExpand(Uint length);
};

}}}


==用户使用==

{{{

    //Sample code for Toy3DPtrArray
    //take Mesh as example;
    TOY3D_PTR ptr;
    Bool rvb;
    Uint size = 16;
    Toy3DPtrArray mPtrArray = new Toy3DPtrArray();

    mPtrArray.createPtrArray();
    ptr = malloc(sizeof(Mesh));
    rvb = mPtrArray.append(ptr);
    if(!rvb)
    {
        printf("append ptr element error.\n");
        return;
    }
    //the same as
    //mPtrArray[0] = ptr;

    ptr = malloc(sizeof(Mesh));
    mPtrArray.insert(ptr, 0);

    mPtrArray.setSize(size);
    ...

    Mesh *mesh = (Mesh *)getElement(0);
    mPtrArray.destroyPtrArray();

}}}

= Reference =

 * [http://developer.gnome.org/glib/2.34/ glib Manual]