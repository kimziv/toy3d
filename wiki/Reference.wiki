#summary Reference resouce such as doc, codes, links.


= OGREs设计思路 =

camera, light 从 SceneManager 创建

scene node 与 mesh 分离，mesh attach 到 scene node里

Material: 在ogre里面Material的含义不再只是包含光照信息的那个Material的含义了。ogre把texture也加入到了Material里面(还有其他的很多的信息)，这样对于同一种Material最多只用调用一次setmaterial和settexture。(见reference1)

= SceneNode/Entity/Mesh/Submesh =

Mesh: ogre的mesh由一个或者多个submesh构成，每个submesh就对应一个Material，绘制的时候submesh是一个基本的单元。(见reference1)

Entities 是以 Meshes 作为自身基础的，Mesh 对象包括了一整套用来描述自身模型的数据。多个Entities 可以共用一种网格，比如，常常会在一个场景下创建同一种对象的多个拷贝。
[http://www.cnblogs.com/leisure/archive/2012/06/29/2568915.html entity, mesh, submesh 的关系]

{{{
    Ogre::Entity* entNinja = mSceneMgr->createEntity("Ninja", "ninja.mesh");
    entNinja->setCastShadows(true);
    mSceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(entNinja);
 
    Ogre::Plane plane(Ogre::Vector3::UNIT_Y, 0);
 
    Ogre::MeshManager::getSingleton().createPlane("ground", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
        plane, 1500, 1500, 20, 20, true, 1, 5, 5, Ogre::Vector3::UNIT_Z);
 
    Ogre::Entity* entGround = mSceneMgr->createEntity("GroundEntity", "ground");
    mSceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(entGround);
 
    entGround->setMaterialName("Examples/Rockwall");
    entGround->setCastShadows(false);

}}}
 

= material-technique-pass =

基本概念：
 * Pass是最基本的绘制单元，同时也是Renderable（可绘制对象）用来标识自己绘制状态的基本单元。
 * Technique是对Pass的集中管理，同时引入了硬件的考量
 * Material是管理的Technique的类
 * MaterialManager，对Material进行管理。主要实现了对纹理过滤的设置、Scheme的管理，设置相应的监听等操作。还负责读取材质脚本、初始化材质资源。


包含关系：
 * 1Material->n Techinque->(n Pass + extra params)->(n TextureUnit + m or 0 shaderUnit + n RenderStates（部分）)
 * Pass里的TextureUnit又包含了这一组texture的相关信息和设置，TexcoordSet, AddressMode, FilterSetting等等， 
 * ShaderUnit则是对应于vs，fs以及新的gs，普通点也就最多两组。
 * shaderUnit包含了具体的shader和其shaderParams，为何要把shader和shaderParams分开呢，不说设计优雅的考虑，简单的说就是方便，很多时候params可能会需要共享，譬如shaderA里用到mvpMat，和eyePos， diffuse,specular,可能shaderB也只用到这些，但是两个shader的内部计算并不相同。


ogre的material system还是相当易读的，也是因为这些模块相互关系几乎都是单向的，我们开始编写的时候可以先不考虑Technique，就是直接1 Material->n Pass->...当然甚至你都可以把multi pass去掉,就等同于1个pass，当然由于pass都代码实际也没多少，我们还是加上好了。

= 多流技术 = 

ogre使用了多流的技术，把vertex的positon，normal，texcord这些数据分开，放到多个流里面进行渲染，这方面的技术可以参考[http://dev.gameres.com/Program/Visual/3D/multistream.htm D3D中多流的用法]。(见reference1)

= OGRE 渲染过程 =

OGRE 渲染过程(见reference1)： 

在ogre里面，场景组织成一棵树形结构，而每一个可以画到屏幕上的物体都是一个renderable，在渲染的时候，ogre遍历场景树，利用剪裁算法（最基本的就是基于视锥的剪裁算法）剔出完全不可见的renderable，把可见的renderable放如到渲染队列里面，最后把渲染队列里面的renderable按照需要进行渲染。


渲染队列保存了所以这一次必须要渲染的物体的信息。它的构成比较的复杂，渲染队列被分成了好多个组（group），这些group都和一个id对于，越小GroupId的group就越先渲染。而每个group又被分成了很多个PriorityGroup，每一个PriorityGroup同样对于一个id，同样是越小的id就越先渲染。而PriorityGroup就是比较基本的渲染单元了。经过两次划分以后为于同一个PriorityGroup的renderable再次分组，这是因为透明物要进行特殊的处理，需要作透明处理的renderable进入一个vector，不要作透明处理的renderable按照它的Material进行分类，有着相同的Material的renderable进行同一个vector。到了最后渲染的时候，按照id遍历每个group，对于每个group，按照id遍历PriorityGroup，对于每个PriorityGroup，首先执行不透明物体的处理，然后把透明物体按照相对摄像机的远近进行排序，依次渲染每一个renderable，然后重复下一个PriorityGroup，然后是group。(见reference1)

下面是ogre的渲染伪代码。

{{{

for 每一个group
{
　　for 每一个 PriorityGroup
　　{
　　　　// 不透明部分
　　　　for 对于每一种Material
　　　　{
　　　　　　SetMaterial() // 包括了texture等等的属性
　　　　　　for 所有这种Material的Renderable
　　　　　　{
　　　　　　　　渲染这个renderable
　　　　　　}
　　　　}

　　　　// 透明部分
　　　　sort()
　　　　for 每一个renderable
　　　　{
　　　　　　SetMaterial()
　　　　　　渲染这个renderable
　　　　}
　　}
}


}}}



为什么要把renderable的优先顺序分成两级？比如把3D物品放到同一个group里面，而2D界面放到一个group里面，这样两个group就可以不受对方的影响，各自安排自己的子优先级。




=最简单的 OGRE 程序=

使用 ManualObject，加载纹理，显示cube，最简单的调用方式：

[http://hsw625728.blog.163.com/blog/static/39570728200910823457100/ 学习OGRE： 绘制一个立方体ManualObject]

[http://hsw625728.blog.163.com/blog/static/3957072820091084913370/ 学习OGRE：加上纹理] 

=Pro OGRE Programming 笔记=

[http://kun-111.blog.163.com/blog/static/40314793200781154032626/ Pro OGRE Programming笔记系列]

= 参考 =

  # [http://gpgame.net/docs/program/ogre.htm ogre的图形渲染方式] 
 