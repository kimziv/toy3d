#summary Toy3D 中用的 listener，如 framelistener, targetlistenter 等

= 观察者模式 =

C语言中的回调函数


 

= Frame Listener =

给用户提供机会在开始每一帧之前和之后做一些事情，比如设置 set entity visible

实现方法：
 * 设计一个基类作为接口
 * 定义 FrameListener 容器，保存所有注册了的帧监听
 * 在 renderOenFrame 里绘制每帧都调用基类的函数
 * 用户使用时，先基于基类实现自己的 frame listener，然后注册到容器中


基类 FrameListener 的设计：

{{{

class FrameListener
{
public:
    virtual bool frameStarted () {return TRUE};
    virtual bool frameEnded() {return TRUE};

};

}}}

World 中定义 FrameListener 容器

{{{

class World
{ 
    TPArray mFrameListeners;
}

World::World()
{
    mFrameListeners.create();
}


}}}


renderOneFrame 中的处理：

{{{



Bool World::renderOneFrame ()
{

    if(fireFrameStarted())   //user implemnet it to do something
        
 
    updateAllRenderTargets();

    return fireFrameEnded();     //user implement it to do something
}

bool World::fireFrameStarted ()
{
    for (int i = 0; i < mFrameListeners.getLength(); i++) {
        FrameListerer* fl = mFrameListeners.geElement(i);
        if(fl->frameStarted())
            return FALSE;
    }

    return TRUE;
}


bool World::fireFrameEnded ()
{
    for (int i = 0; i < mFrameListeners.getLength(); i++) {
        FrameListerer* fl = mFrameListeners.geElement(i);
        if(fl->frameEnded())
            return FALSE;
    }

    return TRUE;
}


    
}}}


注册和删除 frame listener


{{{

void World::addFrameListener:(FrameListener* newListener)
{
    mFrameListeners.append (newListener);
}


void World::removeFrameListener:(FrameListener* oldListener)
{
    mFrameListeners.append (oldListener);
}


}}}

使用代码样例：


{{{

class myApp:public FrameListener
{
    myApp()
    ~myApp();

    void createScene();
    void startRendering();
    void changeWindowSize (int w, int h);

    Bool frameStarted();
    Bool frameEnded ();

    World *mWorld;
    Camera *mCamera;
    RenderWindow *mWin;
    Entity *mRect;
    
    
}


void myApp::App ()
{
    mWorld = NULL;
    mCamera = NULL;
    mRenderWindow = NULL;
    mRect = NULL;
    
}


void myApp::createScene ()
{
    mWorld->new World();
    mWorld->setSize(...);
    mWorld->setBackColor(...);

    mWorld->addFrameListener(this);
  
    mCamera = world->createCamera(...);

    mWin = world->createRenderWindow();
    mWin->addViewport (camera, 0,0, w, h);
    
    ShaderProgram ...
    mesh...
    entity...

    

    return;
    
}

void myApp::changeWindowSize (int w, int h)
{
    world->setSize(w, h);

    camera->perspective (fovy, aspect, nearz, farz);
    camera->lookAt (...）；
}

void myApp::startRenderering ()
{
    mWorld->renderOneFrame();
}

Bool myApp::frameStarted()
{
    isVisible = mRect->setVisible();
    mRect->setVisible(!isVisible);

    return true;
}





====


void init()
{
    
}

void render()
{
}








}}}

= target listener =

给用户提供机会在update每一个 target 之前和之后做一些事情，比如在多个 shader 间切换

基本思路如 frame listener 类似，实现方法：
 * 设计一个基类作为接口
 * 在World中定义 FrameListener 容器，保存所有注册了的帧监听
 * 在 RenderTarget 中每次 update 之前、之后都调用基类的函数
 * 用户使用时，先基于基类实现自己的 target listener，然后注册到容器中



{{{

class RenderTargetListener
{
public:
    virtual ~RenderTargetListener() {}
    virtual void preRenderTargetUpdate() {}
    virtual void postRenderTargetUpdate() {}
    virtual void preViewportUpdate() {}
    virtual void postViewportUpdate() {}
    virtual void viewportAdded() {}
    virtual void viewportRemoved() {}
}


class RenderTarget
{
private:
    TPtrArray mListeners;


    /* Internal function */
    virtual void firePreUpdate();
    virtual void firePostUpdate();


public:
    virtual void addListener (RenderTargetListener * listener);
    virtual void removeListener (RenderTargetListener *listener);
    virtual void removeAllListeners (void);
}



void RenderTarget::update()
{

    firePreUpdate()

    updateAllViewports();

    firePostUpdate()
}


void RenderTarget:;firePreUpdate()
{
    for (all target listeners)
        tl->preRenderTargetUpate()
}

void RenderTarget::firePostUpdate()
{
    for (all target listeners)
        tl->postRenderTargetUpate()

}


}}}