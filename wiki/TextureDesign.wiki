#summary Texture Related modules

=资源管理策略=

= Texture =
{{{
enum TextureState {
    T3D_UNLOADED,
    T3D_LOADED,
    //T3D_UNGENERATED,//this state maybe unnecessary. 
    T3D_GENERATED
};

typdef sttuct _TextureParameter {
    TextureParameterName paraName;
    TextureParameterVal paraVal;
    TextureDataType dataType;
    PixelFormat format;
}TextureParameter;

class Texture {
private:
    int mT3DTexID;
    int mTexID;
    bool mIsUsing;
    char *pFileName;
    ImageInfo *pImageInfo;
    TextureState mState;
    TextureParameter mParam;

public:
    void load(...);
    void unload(...);
    void generate(...);
    void degenerate(...);
    void setParameter(...);
}

}}}

= TextureManager =

TextureManager 设计成  Singleton

基本原则：

 * 用户设置最大可用显存和内存。引擎会根据消耗来维护当前可用内存和显存。

 * 纹理的存储
    用户创建Texture对象后，由TextureManager负责维护，TextureManager类会建立一个指针数组来存储这些纹理对象。在需要使用纹理数据的地方，调用相关接口执行生成、加载、卸载或者删除操作。

 * 纹理的级别：常用和普通。
    常用纹理优先级高，如果可用空间足够，常用纹理会常驻在内存和显存中。

 * 纹理的替换规则。
    当设置的可用内存和显存足够时，纹理可以被直接加载和生成。

    当显存或内存已满，需要先卸载或删除内存或显存中的一部分数据。如果存在非常用的纹理则优先操作，如果全部是常用纹理则按照LRU执行。

    此处为了管理方便，使用两个数组，分别记录已经加载和已经生成的纹理，且元素索引根据使用时间的先后从低到高，执行操作时，也将保证元素的先后顺序。

类定义 TextureManager.h：

{{{

/*
enum TextureManageRule {
    T3D_LRU,
    T3D_FIFO
}
*/

class TextureManager {

protected:
    static TextureManager* mInstance;
    TextureManager();
    Uint mMaxVMemory;
    Uint mMaxMemory;
    Uint mCurrentVM;
    Uint mCurrentM;
    TPtrArray *mTextures;
    TPrtArray *mLoadedTexid;
    TPtrArray *mGenTexid;

public:
    static TextureManager* getInstance();
    ~TextureManager();

    //bool setManageRule(TextureManageRule tmr);
    Texture* createTexture(...);
    void loadTexture(...);
    void unloadTexture(...);
    void generateTexture(...);
    void degenerateTexture(...);
    void destroy(...);
    void destroyAll();

    Texture* getTexture(int texid);
    TextureState getTextureState(int texid);
    bool isTextureUsing(int texid);
    

};


}}}


类实现 TextureManager.cpp：

{{{

TextureManager* TextureManager::mInstance = NULL;

TextureManager* TextureManager::getInstance()
{

    if (NULL == mInstance)
        mInstance = new TextureManager();

    return mInstance;
}


TextureManager::TextureManager ()
{
}


TextureManager::~TextureManager ()
{
}


}}}

单件 TextureManager的使用：

{{{
    TextureManager::getInstance()->createTextureByFile("leaf.tga");
}}}


= 使用样例 =

{{{

void init ()

{
   //world,camera, shaderprogram
   ...
    Entity *entity;
    Material *mat;

   //create texture
   Texture *texture = TextureManager::getInstance()->createTextureByFile("leaf.tga");

    mat = MaterialManager::getInstance()->createMaterial();
    mat->setShaderProgram (shaderProgram);
    mat->setTexture(tex);

    //Create mesh and
    Mesh *mesh = world->createMesh();
    mesh->setVertices (vertices, VERTEX_COUNT);
    mesh->setRenderMode (TOY3D_TRIANGLE_STRIP);
    mesh->setUVs( uvs, VERTEX_COUNT);

    entity = world->createEntity();
    entity->setMesh(mesh);
    entity->setMaterial (mat);
}

void startRendering (Entity entity)
{
    //entity-待绘制对象，假定其中数据已经设置好
    Texture *tex;
    TextureState ts;
    TextureManager tm;

    tex = entity.getMaterial().getTexture();
    ts = tm.getTextureState(tex);
    if(T3D_UNLOADED==ts)
    {
        tm.loadTexture(tex);
    }
    if(T3D_LOADED==ts)
    {
        tm.generateTexture(tex);
    }

    //render
    ...

    return;
}


}}}