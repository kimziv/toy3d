#summary Texture Related modules

=资源管理策略=
==Resource==
 * 1 每个Resource有唯一的 Name 
 * 2 Resource有两种状态
    即：LoadingState和UsingState。二者分别表示资源的加载情况、使用情况。
 * 3 Resource的级别
    常用和普通。其中，常用级别高。
 * 4 Resource类自己实现载入和卸载操作 
 * 5 Resource必须在一段时间不使用时被删除 

==ResourceManager==
 * 1 所有ResourceManager都使用单例模式(Singleton)
 * 2 ResourceManager维护资源池，资源池保存已经创建的资源。
 * 3 ResourceManager负责Resource的创建和删除。
创建后的资源加入资源池，而删除则从资源池中删除。
 * 4 ResourceManager提供资源池的管理策略。
 * 5 ResourceManager负责维护内存、显存预算
并根据实际情况维护这些预算值。

==TextureManager实现==
 * 内存、显存预算：
1 提供成员变量，记录最大、当前的可用内存、显存。

2 提供显存、内存预算设置接口。

3 引擎在创建、删除等操作时，根据消耗来维护当前可用内存、显存。

 * 纹理的存储和管理：
1 提供一个指针数组成员变量，存储创建的纹理，以下称为纹理数组。

2 管理策略：LRU。

2.1 纹理数组只允许在末尾追加元素，以使数组索引从低到高符合时间顺序；

2.2 当内存、显存足够使用时，直接加载、生成纹理；

2.3 当内存或者显存不够时，卸载或销毁某些纹理，以得到足够使用的内存或者显存；

2.4 当需要移除元素时，按照从后向前的顺序遍历顺组；

2.5 可以从任何位置移除元素，移除一个元素之后，其位置之后如果还有元素，这些元素将有序前移；

2.6 正在使用的纹理不能被移除；

2.7 移除纹理将先对优先级低的进行操作，当无可操作对象时，再考虑优先级高的；

3 提供纹理的创建、删除接口。

4 提供纹理的加载、重加载、卸载、生成、销毁接口，这些接口中调用纹理类提供的接口。


= Texture =
{{{

/*
 *  the definition of texture
 *  the base operation of texture :load, generate, degenerate, unload.
 */
class Texture 
{
    enum TextureLoadingState
    {
        TOY3D_UNLOADED,
        TOY3D_LOADED,
        //TOY3D_UNGENERATED,//this state maybe unnecessary.
        TOY3D_GENERATED
    };

    /*
    enum TextureParameterName
    {
        GL_TEXTURE_MAG_FILTER,
        GL_TEXTURE_MIN_FILTER,
        GL_TEXTURE_WRAP_S,
        GL_TEXTURE_WRAP_T
    };

    enum TextureParameterVal
    {
        GL_NEAREST,
        GL_LINEAR,
        GL_NEAREST_MIPMAP_NEAREST,
        GL_LINEAR_MIPMAP_NEAREST,
        GL_NEAREST_MIPMAP_LINEAR,
        GL_LINEAR_MIPMAP_LINEAR,
        GL_CLAMP,
        GL_REPEAT;
    };

    enum TextureDataType
    {
        GL_BYTE,
        GL_UNSIGNED_BYTE,
        GL_SHORT,
        GL_UNSIGNED_SHORT,
        GL_INT,
        GL_UNSIGNED_INT,
        GL_FLOAT,
        GL_FIXED
    };

    enum PixelFormat
    {
        GL_DEPTH_COMPONENT,
        GL_ALPHA,
        GL_RGB,
        GL_RGBA,
        GL_LUMINANCE,
        GL_LUMINANCE_ALPHA
    };

    typedef struct _TextureParameter
    {
        TextureParameterName paraName;
        TextureParameterVal paraVal;
        TextureDataType dataType;
        PixelFormat format;
    }TextureParameter;
    /*

    private:

    protected:
        /* the base member */
        char mName[MAX_NAME_LEN_BIG]; /* the resource file name */
        //char mFileName[MAX_NAME_LEN_BIG];

        Uint mTextureID;
        Uint mWidth;
        Uint mHeight;
        Uint mBytesPerPixel;
        unsigned char *mPixelData;

        //TextureParameter mParameter;

        /* the extended member */
        Bool mIsResident;
        volatile Uint mIdleLevel;
        volatile TextureLoadingState mLoadingState;
        volatile Bool mIsBeingUsed;

    public:
        //Texture();
        //Texture(char *pFileName);
        Texture(char *pFileName, Bool isResident = FALSE);
        ~Texture();

        /* 
         * The interfaces are used for textures created by the constructor with more than one parameter.
         */
        //Bool load();
        /*
         * The interface is used for textures created by the constructor with one parameter.
         */
        //Bool load(char *pFileName);
        Bool load(Image *image);
        Bool load(unsigned char *pImageData, Uint width, Uint height, Uint bytesPerPixel);

        Bool unload();

        Bool generate();
        Bool degenerate();

        void setIdleLevel(Uint value);

        const Bool isResident() const;
        const Bool getUsingState() const;
        const TextureLoadingState getLoadingState() const;
        const Uint getIdleLevel() const;

        const Uint getTextureID() const;
        const char* getTextureName() const;
        const char* getTextureResFileName() const;
}


}}}

= TextureManager =

类定义 TextureManager.h：

{{{

/*
enum TextureManageRule {
    T3D_LRU,
    T3D_FIFO
}
*/

class TextureManager {

protected:
    static TextureManager* mInstance;
    TextureManager();
    Uint mMaxVMemory;
    Uint mMaxMemory;
    Uint mCurrentVM;
    Uint mCurrentM;
    TPtrArray *mTextures;
    TPrtArray *mLoadedTexid;
    TPtrArray *mGenTexid;

public:
    static TextureManager* getInstance();
    ~TextureManager();

    //bool setManageRule(TextureManageRule tmr);
    Texture* createTexture(...);
    void loadTexture(...);
    void unloadTexture(...);
    void generateTexture(...);
    void degenerateTexture(...);
    void destroy(...);
    void destroyAll();

    Texture* getTexture(int texid);
    TextureState getTextureState(int texid);
    bool isTextureUsing(int texid);
    

};


}}}


类实现 TextureManager.cpp：

{{{

TextureManager* TextureManager::mInstance = NULL;

TextureManager* TextureManager::getInstance()
{

    if (NULL == mInstance)
        mInstance = new TextureManager();

    return mInstance;
}


TextureManager::TextureManager ()
{
}


TextureManager::~TextureManager ()
{
}


}}}

单件 TextureManager的使用：

{{{
    TextureManager::getInstance()->createTextureByFile("leaf.tga");
}}}


= 使用样例 =

{{{

void init ()

{
   //world,camera, shaderprogram
   ...
    Entity *entity;
    Material *mat;

   //create texture
   Texture *texture = TextureManager::getInstance()->createTextureByFile("leaf.tga");

    mat = MaterialManager::getInstance()->createMaterial();
    mat->setShaderProgram (shaderProgram);
    mat->setTexture(tex);

    //Create mesh and
    Mesh *mesh = world->createMesh();
    mesh->setVertices (vertices, VERTEX_COUNT);
    mesh->setRenderMode (TOY3D_TRIANGLE_STRIP);
    mesh->setUVs( uvs, VERTEX_COUNT);

    entity = world->createEntity();
    entity->setMesh(mesh);
    entity->setMaterial (mat);
}

void startRendering (Entity entity)
{
    //entity-待绘制对象，假定其中数据已经设置好
    Texture *tex;
    TextureState ts;
    TextureManager tm;

    tex = entity.getMaterial().getTexture();
    ts = tm.getTextureState(tex);
    if(T3D_UNLOADED==ts)
    {
        tm.loadTexture(tex);
    }
    if(T3D_LOADED==ts)
    {
        tm.generateTexture(tex);
    }

    //render
    ...

    return;
}


}}}