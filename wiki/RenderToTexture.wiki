#summary One-sentence summary of this page.

= 简介 =

主要思路:   
 * glCopyTexImage：把 framebuffer 的东西拷贝到纹理
 * Pbuffer  
 * FBO
 * PBO

目前流行用 FBO。

参考资源1


=FBO基本渲染流程=


{{{

    ...
    // set rendering destination to FBO
    glBindFramebuffer(GL_FRAMEBUFFER, fboId);


     /* Draw base layer texture */
    
    //attach base layer texture
    glFrameBufferAttach (base_layer_texture);

    // clear buffers
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    draw();


    /* Draw road layer texture */

    //attach road layer texture
    glFrameBufferAttach (road_layer_texture);

    // clear buffers
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    draw();


    // unbind FBO
    glBindFramebuffer(GL_FRAMEBUFFER, 0);

    
    //draw two textures  on two screen
     ...


}}}

=OGRE 设计=

{{{


class GLES2RTTManager : public Singleton<GLES2RTTManager>
{
    public:
        virtual ~GLES2RTTManager();

        virtual RenderTexture *createRenderTexture(const String &name, const GLES2SurfaceDesc &target, bool writeGamma, uint fsaa) = 0;

        /** Check if a certain format is usable as rendertexture format
        */
        virtual bool checkFormat(PixelFormat format) = 0;

        /** Bind a certain render target.
        */
        virtual void bind(RenderTarget *target) = 0;

        /** Unbind a certain render target. This is called before binding another RenderTarget, and
            before the context is switched. It can be used to do a copy, or just be a noop if direct
            binding is used.
        */
        virtual void unbind(RenderTarget *target) = 0;


        /** Create a multi render target
        */
        virtual MultiRenderTarget* createMultiRenderTarget(const String & name);

        /** Get the closest supported alternative format. If format is supported, returns format.
        */
        virtual PixelFormat getSupportedAlternative(PixelFormat format);
    };






void GLES2RenderSystem::_setRenderTarget(RenderTarget *target)
{

    // Unbind frame buffer object
    if(mActiveRenderTarget && mRTTManager)
        mRTTManager->unbind(mActiveRenderTarget);

    mActiveRenderTarget = target;
    if (target)
    {
        // Switch context if different from current one
        GLES2Context *newContext = 0;
        target->getCustomAttribute("GLCONTEXT", &newContext);
        if (newContext && mCurrentContext != newContext)
        {
             _switchContext(newContext);
        }

        // Check the FBO's depth buffer status
        GLES2DepthBuffer *depthBuffer = static_cast<GLES2DepthBuffer*>(target->getDepthBuffer());

        if( target->getDepthBufferPool() != DepthBuffer::POOL_NO_DEPTH &&
                (!depthBuffer || depthBuffer->getGLContext() != mCurrentContext ) )
        {
            // Depth is automatically managed and there is no depth buffer attached to this RT
            // or the Current context doesn't match the one this Depth buffer was created with
            setDepthBufferFor( target );
        }

        // Bind frame buffer object
        mRTTManager->bind(target);
    }


}


viod RenderSystem::_setViewPort (Viewport *vp)
{

    if (!vp){
        mActiveViewport = NULL;
        _setRenderTarget (NULL);
    }
    else if (vp != mActiveViewport || vp->_isUpdated()) {

        RenderTarget *target;
        target = vp->getTarget();
        _setRenderTarget(target);
        mActiveViewport = vp;

        ... 
        glViewport (x, y,w, h);
        glScissor (x, y, w, h);
        ....


    }


}

}}}


= Reference =

  * [http://blog.csdn.net/Nhsoft/article/details/1105309 OpenGL 中的 Render To Texture] 
  * [http://processors.wiki.ti.com/index.php/Render_to_Texture_with_OpenGL_ES Render to Texture with OpenGL ES]
  * [http://www.songho.ca/opengl/gl_fbo.html opengl FBO]
  * [http://blog.csdn.net/leonwei/article/details/5740728 OGRE 渲染到纹理]