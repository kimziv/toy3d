#summary One-sentence summary of this page.

= 简介 =

主要思路:   
 * glCopyTexImage：把 framebuffer 的东西拷贝到纹理
 * Pbuffer  
 * FBO
 * PBO

目前流行用 FBO。

参考资源1


=FBO基本渲染流程=


{{{
    GLint fboId;
    glGenFramebuffers(1, &fboId);

    // set rendering destination to FBO
    glBindFramebuffer(GL_FRAMEBUFFER, fboId);


    /* Draw base layer texture */
    glFramebufferTexture2D(...);
    
    //attach base layer texture
    glFrameBufferAttach (base_layer_texture);

    // clear buffers
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    draw();


    /* Draw road layer texture */

    //attach road layer texture
    glFrameBufferAttach (road_layer_texture);

    // clear buffers
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    draw();


    // unbind FBO
    glBindFramebuffer(GL_FRAMEBUFFER, 0);

    
    //draw two textures  on two screen
     ...

    glDeleteFramebuffers(1, &fboId);

}}}

=OGRE 设计=

{{{


class GLES2RTTManager : public Singleton<GLES2RTTManager>
{
    public:
        virtual ~GLES2RTTManager();

        virtual RenderTexture *createRenderTexture(const String &name, const GLES2SurfaceDesc &target, bool writeGamma, uint fsaa) = 0;

        /** Check if a certain format is usable as rendertexture format
        */
        virtual bool checkFormat(PixelFormat format) = 0;

        /** Bind a certain render target.
        */
        virtual void bind(RenderTarget *target) = 0;

        /** Unbind a certain render target. This is called before binding another RenderTarget, and
            before the context is switched. It can be used to do a copy, or just be a noop if direct
            binding is used.
        */
        virtual void unbind(RenderTarget *target) = 0;


        /** Create a multi render target
        */
        virtual MultiRenderTarget* createMultiRenderTarget(const String & name);

        /** Get the closest supported alternative format. If format is supported, returns format.
        */
        virtual PixelFormat getSupportedAlternative(PixelFormat format);
};






void GLES2RenderSystem::_setRenderTarget(RenderTarget *target)
{

    // Unbind frame buffer object
    if(mActiveRenderTarget && mRTTManager)
        mRTTManager->unbind(mActiveRenderTarget);

    mActiveRenderTarget = target;
    if (target)
    {
        // Switch context if different from current one
        GLES2Context *newContext = 0;
        target->getCustomAttribute("GLCONTEXT", &newContext);
        if (newContext && mCurrentContext != newContext)
        {
             _switchContext(newContext);
        }

        // Check the FBO's depth buffer status
        GLES2DepthBuffer *depthBuffer = static_cast<GLES2DepthBuffer*>(target->getDepthBuffer());

        if( target->getDepthBufferPool() != DepthBuffer::POOL_NO_DEPTH &&
                (!depthBuffer || depthBuffer->getGLContext() != mCurrentContext ) )
        {
            // Depth is automatically managed and there is no depth buffer attached to this RT
            // or the Current context doesn't match the one this Depth buffer was created with
            setDepthBufferFor( target );
        }

        // Bind frame buffer object
        mRTTManager->bind(target);
    }


}


viod GLES2RenderSystem::_setViewPort (Viewport *vp)
{

    if (!vp){
        mActiveViewport = NULL;
        _setRenderTarget (NULL);
    }
    else if (vp != mActiveViewport || vp->_isUpdated()) {

        RenderTarget *target;
        target = vp->getTarget();
        _setRenderTarget(target);
        mActiveViewport = vp;

        ... 
        glViewport (x, y,w, h);
        glScissor (x, y, w, h);
        ....


    }


}


void SceneManager::manualRender(Renderable* rend, const Pass* pass, Viewport* vp,
    const Matrix4& viewMatrix,
    const Matrix4& projMatrix,bool doBeginEndFrame,
    bool lightScissoringClipping, bool doLightIteration, const LightList* manualLightList)
{
    if (vp)
        mDestRenderSystem->_setViewport(vp);

    if (doBeginEndFrame)
        mDestRenderSystem->_beginFrame();

    setViewMatrix(viewMatrix);
    mDestRenderSystem->_setProjectionMatrix(projMatrix);

    _setPass(pass);
    Camera dummyCam(StringUtil::BLANK, 0);
    dummyCam.setCustomViewMatrix(true, viewMatrix);
    dummyCam.setCustomProjectionMatrix(true, projMatrix);
    // Do we need to update GPU program parameters?
    if (pass->isProgrammable())
    {
        if (vp)
        {
            mAutoParamDataSource->setCurrentViewport(vp);
            mAutoParamDataSource->setCurrentRenderTarget(vp->getTarget());
        }
        mAutoParamDataSource->setCurrentSceneManager(this);
        mAutoParamDataSource->setCurrentCamera(&dummyCam, false);
        updateGpuProgramParameters(pass);
    }
    if (vp)
        mCurrentViewport = vp;
    renderSingleObject(rend, pass, lightScissoringClipping, doLightIteration, manualLightList);


    if (doBeginEndFrame)
        mDestRenderSystem->_endFrame();

}




}}}


OGRE 渲染到纹理使用样例

{{{

TexturePtr texture = TextureManager::getSingleton().createManual( "RttTex",

         ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, TEX_TYPE_2D,

         512, 512, 0, PF_R8G8B8, TU_RENDERTARGET );



RenderTarget *rttTex = texture->getBuffer()->getRenderTarget();

mReflectCam = mSceneMgr->createCamera("ReflectCam");
mReflectCam->setNearClipDistance(mCamera->getNearClipDistance());
mReflectCam->setFarClipDistance(mCamera->getFarClipDistance());
mReflectCam->setAspectRatio(
                (Real)mWindow->getViewport(0)->getActualWidth() /
                (Real)mWindow->getViewport(0)->getActualHeight());
Viewport *v = rttTex->addViewport( mReflectCam );
v->setClearEveryFrame( true );
v->setBackgroundColour( ColourValue::Black );


}}}


RenderTarget 
 # 接收渲染结果
 # 创建维护 Viewport
 # 一个 Viewport 对应一个 Camera和一个 RenderTarget
 # 一个 Camera 对应一个 Viewport
 # 一个 RenderTarget 可拥有对个 Viewport

{{{


class RenderTarget 
{
    ViewportList mViewportList;

    Viewport* addViewport (Camera *cam, int ZOrder, float f, t, w, h);


}

}}}



=样例=

可做的样例：
 # 镜面反射效果
 # 地图

样例的实现：
 # 2个 camera


= Reference =

  * [http://blog.csdn.net/Nhsoft/article/details/1105309 OpenGL 中的 Render To Texture] 
  * [http://processors.wiki.ti.com/index.php/Render_to_Texture_with_OpenGL_ES Render to Texture with OpenGL ES]
  * [http://www.songho.ca/opengl/gl_fbo.html opengl FBO]
  * [http://blog.csdn.net/leonwei/article/details/5740728 OGRE 渲染到纹理]
  * [http://www.zwqxin.com/archives/opengl/learn-fbo.html 学一学VBO]