#summary 增加 TextureUnit 支持

=todolist=

 * MultiTexture 例子

 * [http://blog.csdn.net/programrookie/article/details/4552447 实现动态纹理作为验证]


=使用样例=

{{{

  Material *mat = MaterialManager::getInstance()->createMaterial();
  mat->setShader(shaderProgram);

  //mat->setTexture(tex);   /* old job*/  
  mMat->createTextureUnitState( “xue.jpg” );

}}}


=Material/TextureUnitState=

{{{

class Material
{
private:
    TPtrArray      mTextureUnitStates;

    Bool searchTextureUnitState(char *name) const;

public:
    TextureUnitState* createTextureUnitState(char *name);
    Bool addTextureUnitState(TextureUnitState *texUnitState);
    TextureUnitState* getTextureUnitState(char *name);
    TextureUnitState* getAllTextureUnitStates(Uint *count);
}

enum TextureTarget
{
    T3D_TEXTURE_1D,
    T3D_TEXTURE_2D,
    T3D_TEXTURE_3D
};

enum TextureParameterName
{
    T3D_TEXTURE_MAG_FILTER,
    T3D_TEXTURE_MIN_FILTER,
    T3D_TEXTURE_WRAP_S,
    T3D_TEXTURE_WRAP_T
};

enum TextureParameterVal
{
    /* The following parameters are applicable to T3D_TEXTURE_MAG_FILTER. */
    T3D_NEAREST,
    T3D_LINEAR,

    /* The following parameters are applicable to T3D_TEXTURE_MAG_FILTER and T3D_TEXTURE_MIN_FILTER. */
    T3D_NEAREST_MIPMAP_NEAREST,
    T3D_LINEAR_MIPMAP_NEAREST,
    T3D_NEAREST_MIPMAP_LINEAR,
    T3D_LINEAR_MIPMAP_LINEAR,

    /* The following parameters are applicable to T3D_TEXTURE_WRAP_S and T3D_TEXTURE_WRAP_T. */
    T3D_CLAMP,
    T3D_REPEAT,
    T3D_MIRRORED_REPEAT
};

class TextureUnitState
{
private:
    char             mName[MAX_NAME_LEN];
    TPtrArray        *mTextures;

    TextureTarget       mTarget;
    TextureParameterVal mTexMinFilter;
    TextureParameterVal mTexMagFilter;
    TextureParameterVal mTexWrapS;
    TextureParameterVal mTexWrapT;

protected:

public:
    TextureUnitState();
    TextureUnitState(char *name);
    ~TextureUnitState();

    void setName(char *name);

    void setTexture(char *name);
    void setTexture(Texture *pTexture);
    void removeTexture(Texture *pTexture);

    const Uint getTextureCount() const;
    Texture* getAllTextures(Uint *count);

    void setTextureTarget(TextureTarget target);
    void setTextureParameter(TextureParameterName name, TextureParameterVal val);

    TextureTarget getTextureTarget();
    TextureParameterVal getTextureParameterVal(TextureParameterName name);

};

/*
class TextureUnitState 
{  
    PtrArray mTexturePtrs;
 
    void setTextureName (name);
}
*/
 
}}}

=TextureManager/Texture=

{{{
//此部分暂未作改变
class TextureManager 
{
 
    Map  mTexturePtrMap;

    size_t mMemoryBudget;  //in bytes
    size_t mMemoryUsage;   //in bytes
 

    void setMemoryBudget ();
    size_t getMemoryBudget();
    size_t getMemoryUsage ();
 
    Texture* create (name);  //create a new blank resource, but does not immediately load it
 
    Texture* getByName (name);  


    Texture* createOrRetrieve(name);   //getByName return NULL, then call create


    void remove(Texture* tex);   //unload and remove from list
 
    void remove (name);
 


    void removeAll();
 
    void removeUnreferencedResources();
 


    void unload (name);  //not removed, simply free up their memory
 

    void unloadAll();
 
    void reloadAll();
 
    unloadUnreferencedResource();
 
    reloadUnreferencedResource();
    


    bool resoureExist(name);
 

    Texture* prepare (name, );  //load images only, not opengl object
 

    Texture* load (name, numMipmaps, ...); //load into openg object.
 
    Texture* loadImage(name, Image &img, ...);
 
    Texture* loadRawData (name, width, height, format, ...); 

    Texture* createManal(name, w, h, d, rgba, ....);
 
}
 
class Texture
{
 
    GLuint mTextureID;
 
    vector <Image> mLoadedImages;
 

    void prepare();  //load image file to image
 
    void load();
 


    void unload();   // call freeInternalResources
 

    void loadImage(Image& img);     //generate gl texture object
 
    void loadRawData(w, h, format, data);     //generate gl texture object
 

    void createInternalResources ();  //generate gl texture object
    void freeInternalResources ();   //delete opengl texture

}

}}}


=World/Renderer= 

{{{
class Renderer 
{
    void setTextureUnitSettings( Uint unit, TextureUnitState *texUnitState);

private:
    Uint getRealRenderMode(RenderMode mode);

    /* convert blenging factor to the value which the hardware support. */
    Uint getRealBlendFactor(BlendingFactor srcFactor);
    /* convert blenging mode to the value which the hardware support. */
    Uint getRealBlendMode(BlendingMode mode);

    Uint getRealTextureUnit(Uint texUnit);
    Uint getRealTextureTarget(TextureTarget target);
    Uint getRealTextureParameterName(TextureParameterName name);
    int  getRealTextureParameterVal(TextureParameterVal val);
}

void Renderer::setTextureUnitSettings(Uint unit, TextureUnitState *texUnitState)
{
    Uint target;
    Uint parameterName;
    int  parameterVal;
    Uint count, i;
    Texture *tex;

    /* active the texture unit */
    glActiveTexture( getRealTextureUnit(unit) );

    /* get the target */
    target = getRealTextureTarget(texUnitState->getTextureTarget());

    /* set parameters */
    parameterName = getRealTextureParameterName(T3D_TEXTURE_MAG_FILTER);
    parameterVal = getRealTextureParameterVal(
        texUnitState->getTextureParameterVal(T3D_TEXTURE_MAG_FILTER));
    glTexParameteri(target, parameterName, parameterVal);

    parameterName = getRealTextureParameterName(T3D_TEXTURE_MIN_FILTER);
    parameterVal = getRealTextureParameterVal(
        texUnitState->getTextureParameterVal(T3D_TEXTURE_MIN_FILTER));
    glTexParameteri(target, parameterName, parameterVal);

    parameterName = getRealTextureParameterName(T3D_TEXTURE_WRAP_S);
    parameterVal = getRealTextureParameterVal(
        texUnitState->getTextureParameterVal(T3D_TEXTURE_WRAP_S));
    glTexParameteri(target, parameterName, parameterVal);

    parameterName = getRealTextureParameterName(T3D_TEXTURE_WRAP_T);
    parameterVal = getRealTextureParameterVal(
        texUnitState->getTextureParameterVal(T3D_TEXTURE_WRAP_T));
    glTexParameteri(target, parameterName, parameterVal);

    /* bind each texture */
    tex = texUnitState->getAllTextures(&count);
    for(i=0;i<count;i++)
    {
        glBindTexture(target, tex->getTextureID());
        tex++;
    }

    return;
}

/*
void Renderer::_setTextureUnitSettings(texUnit, TextureUnitState* tl)
{
    tex = tl._getTexturePtr();
    _setTexture (texUnit, tex);
    _setTextureCoordSet(texUnit, tl.getTextureCoordSet());
    _setTextureFiltering(texUnit, 
            tl.getTexureFiltering(FT_MIN), 
            tl.getTexureFiltering(FT_MAG), 
            tl.getTexureFiltering(FT_MIP));
    _setTextureLayerAnisotropy(texUnit, tl.getTextureAnisotropy());
    _setTextureMipMapBias(texUnit, tl.getTextureMipmapsBias());
    _setTextureBlendMode(texUnit, tl.getColourBlendMode());
    _setTextureBlendMode(texUnit, tl.getAlphaBlendMode());
    _setTextureXXXX....
}

void Renderer::_setTexture (stage, enabled, texPtr)
{
    activateGLTextureUnit(stage);
    glBindTexture(texPtr);
}
*/

void World::renderOneObject ()
{
/*
    for (all textureUnitState in Material) {
        mRenderer->setTextureUnitSettings (unit, pTex);
    }
*/
    Uint i, count = 0;
    TextureUnitState *texUnits;
    texUnits = mat->getAllTextureUnitStates(&count);

    ...
    for(i=0; i<count; i++)
    {
        mRenderer.setTextureUnitSettings(i, texUnits);
        texUnits++;
    }
    ...
}

}}}