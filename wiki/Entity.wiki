#summary 增加entity.


＝ Entity Mesh ＝

{{{

class Mesh {

private:
    RenderMode mRenderMode;
    Real *mVertices;^M
    Real* mColors;^M
    Real* mUVs;^M
    Real* mNormals;^M

    Uint mVertexCount;


public:
   void getRenderOperation (RenderOpertation *op);
   void setVertices (...);
}

class Entity {

private:
    Real mModelMatrix[MATRIX_4x4_SIZE];
    Mesh *mesh;
    Texture *tex;
    ShaderProgram *mShaderProgram;
    
    
public:
   void translate();
   void rotate();
   void scale ();

   void getRenderOperation (RenderOpertation *op);

   void setMesh (Mesh *mesh);
   void setTexture (Texture *tex);

};

class World {

private:
   Entity *mEntities[MAX_ENTITY_COUNT];
    
   Real mWorldMatrix [MATRIX_4x4_SIZE];

public:
   Entity *createEntity ();
   void startRendering ();

}


void World::updateGpuProgramParams ()
{

    if (mGpuParamsDirty)
        pass->_updateAutoParams(mAutoParamDataSource, mGpuParamsDirty);

    if (pass->hasVertexProgram())
    {   
         mDestRenderSystem->bindGpuProgramParameters(
                GPT_VERTEX_PROGRAM,     
                pass->getVertexProgramParameters(), 
                mGpuParamsDirty);
         }

 
         if (pass->hasFragmentProgram())
         {
             mDestRenderSystem->bindGpuProgramParameters(
                 GPT_FRAGMENT_PROGRA     M,
                 pass->getFragmentProgramParameters(),   
                 mGpuParamsDirty);
         }    
    }
}

Pass* World::_setPass (Pass *pass, ...)
{

    if (pass->hasVertexProgram())
        renderer->bindGpuProgram (pass->getVertexProgram());


    if (pass->hasFragmentProgram())
        renderer->bindGpuProgram (pass->getFragmentProgram());

    
    renderer->_setSceneBlending(pass->getSourceBlendFactor(), pass->getDestBlendFactor());

}


void World::manulRender (RenderOperation*, Pass*, Viewport *p, 
        Matrix4& world, Matrix4& view, Matrix4& proj)
{
    renderer->_setViewPort();

    renderer->_beginFrame();

    renderer->_setWorldMatrix (world);
    renderer->_setViewMatrix (view);
    renderer->_setProjectionMatrix (proj);

    _setPass (pass);

    mAutoParamDataSource->setWorldMatrix (world);
    Camera dummyCam ();
    dummyCam.setCustomViewMatrix (view);
    dummyCam.setCustomProjMatrix (proj);
    mAutoParamDataSource->setCurrentCamera (&dummyCam);
    updateGpuProgramParamers (pass);

   
    renderer->_render(ro);
    
    renderer->_endFrame();
}




void World::startRendering ()
{



}

class Renderer
{

    mCurrentVertexProgram;
    mCurrentFragmentProgram;



    void bindGpuVertexProgram (GpuProgram* prg);
    void bindGpuFragmentProgram (GpuProgra *prg);
}

}}}




= 用户使用 =

{{{

void init ()
{

    world = new World();
    world->setSize (w, h);
    world->setBackColor (r, g, b, a);

    camera= world->cteateCamera ("name");

    prg = new ShaderProgram ();
    prg->loadShaderSource (vert_file,frag_file);
 
    params = new ShaderProgramParams ();

    //auto uniform
    params->setNamedAutoConstant (TOY3D_ACT_PROJECTION_MATRIX, "prj_matrx");
    params->setNamedAutoConstant (TOY3D_ACT_WORLD_MATRIX, "world_matrx");
    params->setNamedAutoConstant (TOY3D_ACT_VIEW_MATRIX, "view_matrx");

    //custom uniform
    params->setNamedCustConstant (type, "sample2d", int);

    //attribution
    params->setNamedAttrConstant (TOY3D_ATTR_VERTEX_INDEX, "vPosition");

    shaderProgram->bindShaderParameters (params);


    //create pass
    pass = new Pass ();
    pass->setShaderProgram (shaderProgram);



    //create mesh
    mesh = new Mesh ();
    mesh->setVertices (vertices, count);
    mesh->setRenderMode (TOY3D_TRIANGLE_STRIP);
    

    Entity* entity = world->createEntity();
    entity->setMesh (mesh);
    entity->setPass (pass);
    
}

void destroy ()
{
    delete camera;
    delete world;
    world->destroyEntities();

}

}}}



Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages