#summary 增加entity.


= 基本思路 =

* 增加 entity，entity 是基本的绘制单元
* entity 包含 mesh 和 pass
* mesh 保存基本的几何数据
* pass 保存 shader,texture, material
* 绘制时将需要绘制的数据传入 renderer 
  # 几何数据通过 renderoperation 传入：renderer->_render(op);
  # shader uniform 调用 bind
 



=Mesh=

{{{

class Mesh {

private:
    RenderMode mRenderMode;
    Real *mVertices;^M
    Real* mColors;^M
    Real* mUVs;^M
    Real* mNormals;^M

    Uint mVertexCount;


public:
   void getRenderOperation (RenderOpertation *op);
   void setVertices (...);
}

}}}

=entity=

{{{

class Entity {

private:
    Real mModelMatrix[MATRIX_4x4_SIZE];
    Mesh *mesh;
    Texture *tex;
    ShaderProgram *mShaderProgram;
    
    
public:
   void translate();
   void rotate();
   void scale ();

   void getRenderOperation (RenderOpertation *op);

   void setMesh (Mesh *mesh);
   void setMaterial (Material *mat);

};

}}}

=Material=


{{{
class material {

private:
    Texture *tex; 
    ShaderProgram *prog;
    

    void setTexture (Texture *tex);
}

}}}

=world=

{{{

class World {

private:
   Entity *mEntities[MAX_ENTITY_COUNT];
    
   Real mWorldMatrix [MATRIX_4x4_SIZE];

public:

   Entity *createEntity (Mesh *mesh);

   
   void destoryAllCameras ();
   void destroyAllEntities ();


   void startRendering ();

}


void World::updateGpuProgramParameters (Material *mat)
{

    if (!mShaderParamsDirty)
        return;

    if (mShaderParamsDirty)
        mat->updateAutoParams (mAutoParamDataSource, bool???);

    renderer->bindGpuProgramParameters (mat->getProgramParameters(), bool???);


}



void World::manualRender (RenderOperation* ro, Material* mat, 
        Real worldMatrix[16], Real viewMatrix[16], Real projMatrix[16])
{
    renderer->setViewPort(0, 0, mWidth,mHeight);

    renderer->beginFrame();


    renderer->bindShaderProgram (mat->getShaderProgram());


    mAutoParamDataSource.setWorldMatrix (worldMatrix);
    mAutoParamDataSource.setViewMatrix (viewmatrix);
    mAutoParamDataSource.setProjMatrix (projMatrix);

    updateGpuProgramParamers ();

   
    renderer->_render(ro);
    
    renderer->endFrame();
}




void World::startRendering ()
{

    for (entity[i]) {
        entity[i]->getRenderOperation (ro);
        mat = entity[i]->getMaterial ();
        worldMatrix = entity[i]->getWorldMatrix ();
        mCamera.getViewMatrix (viewMatrix);
        mCamera.getProjMatrix (projMatrix);

        manualRender (ro, mat, worldMatrix, viewMatrix, projMatrix);
    }

}

}}}


=renderer=

{{{

class Renderer
{

    mCurrentShaderProgram;


    void bindShaderProgram (*prog);
    void bindShaderProgramParameters (*param);
}



void Renderer::bindShaderProgram (*prog)
{
    mCurrentShaderProgram=prog;
}



void Renderer::bindShaderProgramParameters (*param)
{
    mCurrentShaderProgram->bindProgramParameters (params);  //update uniforms
}




}}}

=ShaderProgram=

class ShaderProgram
{

    void bindProgramParameters (ShaderProgramParameters *params);

    void loadSource();
    void loadBinary ()
}

void ShaderProgram::bindProgramParameters ()
{
    updateUniforms(params);

}



= 用户使用 =

{{{

World *world;
Camera *camera;
ShaderProgram *prog;
Material *mat;



void init ()
{

    world = new World();
    world->setSize (w, h);
    world->setBackColor (r, g, b, a);

    camera= world->createCamera ("name");

    prg = new ShaderProgram ();
    prg->loadShaderSource (vert_file,frag_file);
 
    params = new ShaderProgramParams ();

    //auto uniform
    params->setNamedAutoConstant (TOY3D_ACT_PROJECTION_MATRIX, "prj_matrx");
    params->setNamedAutoConstant (TOY3D_ACT_WORLD_MATRIX, "world_matrx");
    params->setNamedAutoConstant (TOY3D_ACT_VIEW_MATRIX, "view_matrx");

    //custom uniform
    params->setNamedCustConstant (type, "sample2d", int);

    //attribution
    params->setNamedAttrConstant (TOY3D_ATTR_VERTEX_INDEX, "vPosition");

    shaderProgram->bindShaderParameters (params);


    //create Material
    mat = new Material ();
    mat->setShaderProgram (shaderProgram);
    //maybe mat->setTexture (tex); 

    //create mesh
    mesh = new Mesh ();
    mesh->setVertices (vertices, count);
    mesh->setRenderMode (TOY3D_TRIANGLE_STRIP);
    

    Entity* entity = world->createEntity();
    entity->setMesh (mesh);
    entity->setMaterial (mat);
    
}

void display ()
{

    world->startRendering();

    swap();

}

void destroy ()
{

    delete params;
    delete shaderProgram;

    delete mat;
    

    //delete camera    
    world->destroyCameras();

    //delete entity
    world->destroyEntities();

    delete world;

}

}}}

=bind Program=

{{{


void World::bindGpuProgram (prog)
{

    mGpuParamsDirty = true;
    renderer->bindGpuProgram (prog);

}


void RenderSystem::bindGpuProgram (prog)
{

   GLES2GpuProgram* glprg = GLES2GpuProgram*(prog)

   

   mCurrentVertexProgram->unbindProgram();
   mCurrentVertexProgram = prog;

   mCurrentFragProgram->unbindProgram();
   mCurrentFragProgram = prog;

   

  glprg->bindProgram(); 
  RenderSystem::bindGpuProgram(prg);

}


world->bindGpuProgram(prog);



}}}

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages