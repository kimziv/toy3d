#summary 增加entity.


= 基本思路 =

* 增加 entity，entity 是基本的绘制单元
* entity 包含 mesh 和 pass
* mesh 保存基本的几何数据
* pass 保存 shader,texture, material
* 绘制时将需要绘制的数据传入 renderer 
  # 几何数据通过 renderoperation 传入：renderer->_render(op);
  # shader uniform 调用 bind
 



=Mesh=

{{{

class Mesh {

private:
    RenderMode mRenderMode;
    Real *mVertices;^M
    Real* mColors;^M
    Real* mUVs;^M
    Real* mNormals;^M

    Uint mVertexCount;


public:
   void getRenderOperation (RenderOpertation *op);
   void setVertices (...);
}

}}}

=entity=

{{{

class Entity {

private:
    Real mModelMatrix[MATRIX_4x4_SIZE];
    Mesh *mesh;
    Texture *tex;
    ShaderProgram *mShaderProgram;
    
    
public:
   void translate();
   void rotate();
   void scale ();

   void getRenderOperation (RenderOpertation *op);

   void setMesh (Mesh *mesh);
   void setMaterial (Material *mat);

};

}}}

=Material=


{{{
class material {

private:
    Texture *tex; 
    ShaderProgram *prog;
    

    void setTexture (Texture *tex);
}

}}}

=world=

{{{

class World {

private:
   Entity *mEntities[MAX_ENTITY_COUNT];
    
   Real mWorldMatrix [MATRIX_4x4_SIZE];

public:

   Entity *createEntity (Mesh *mesh);

   
   void destoryAllCameras ();
   void destroyAllEntities ();


   void startRendering ();

}


void World::updateGpuProgramParams ()
{

    if (mGpuParamsDirty)
        pass->_updateAutoParams(mAutoParamDataSource, mGpuParamsDirty);

    if (pass->hasVertexProgram())
    {   
         mDestRenderSystem->bindGpuProgramParameters(
                GPT_VERTEX_PROGRAM,     
                pass->getVertexProgramParameters(), 
                mGpuParamsDirty);
         }

 
         if (pass->hasFragmentProgram())
         {
             mDestRenderSystem->bindGpuProgramParameters(
                 GPT_FRAGMENT_PROGRA     M,
                 pass->getFragmentProgramParameters(),   
                 mGpuParamsDirty);
         }    
    }
}

Pass* World::_setPass (Pass *pass, ...)
{

    if (pass->hasVertexProgram())
        renderer->bindGpuProgram (pass->getVertexProgram());


    if (pass->hasFragmentProgram())
        renderer->bindGpuProgram (pass->getFragmentProgram());

    
    renderer->_setSceneBlending(pass->getSourceBlendFactor(), pass->getDestBlendFactor());

}


void World::manualRender (RenderOperation* ro, Material* mat, 
        Real worldMatrix[16], Real viewMatrix[16], Real projMatrix[16])
{
    renderer->setViewPort(0, 0, mWidth,mHeight);

    renderer->beginFrame();

/*
    not need
    renderer->_setWorldMatrix (world);
    renderer->_setViewMatrix (view);
    renderer->_setProjectionMatrix (proj);
*/

//    _setPass (pass);

    renderer->bindGpuProgram (mat->getMaterial());

/*
    maybe need
    renderer->setWorldBlending (mat->getSourceBlendFactor(), mat->getDestBlendFactor);
*/

    mAutoParamDataSource->setWorldMatrix (world);
    Camera dummyCam ();
    dummyCam.setCustomViewMatrix (view);
    dummyCam.setCustomProjMatrix (proj);
    mAutoParamDataSource->setCurrentCamera (&dummyCam);
    updateGpuProgramParamers (pass);

   
    renderer->_render(ro);
    
    renderer->endFrame();
}




void World::startRendering ()
{



}

}}}


=renderer=

{{{

class Renderer
{

    mCurrentVertexProgram;
    mCurrentFragmentProgram;



    void bindGpuVertexProgram (GpuProgram* prg);
    void bindGpuFragmentProgram (GpuProgra *prg);
}

void Renderer:startRendering ()
{

    

}

}}}




= 用户使用 =

{{{

World *world;
Camera *camera;
ShaderProgram *prog;
Material *mat;



void init ()
{

    world = new World();
    world->setSize (w, h);
    world->setBackColor (r, g, b, a);

    camera= world->createCamera ("name");

    prg = new ShaderProgram ();
    prg->loadShaderSource (vert_file,frag_file);
 
    params = new ShaderProgramParams ();

    //auto uniform
    params->setNamedAutoConstant (TOY3D_ACT_PROJECTION_MATRIX, "prj_matrx");
    params->setNamedAutoConstant (TOY3D_ACT_WORLD_MATRIX, "world_matrx");
    params->setNamedAutoConstant (TOY3D_ACT_VIEW_MATRIX, "view_matrx");

    //custom uniform
    params->setNamedCustConstant (type, "sample2d", int);

    //attribution
    params->setNamedAttrConstant (TOY3D_ATTR_VERTEX_INDEX, "vPosition");

    shaderProgram->bindShaderParameters (params);


    //create Material
    mat = new Material ();
    mat->setShaderProgram (shaderProgram);
    //maybe mat->setTexture (tex); 

    //create mesh
    mesh = new Mesh ();
    mesh->setVertices (vertices, count);
    mesh->setRenderMode (TOY3D_TRIANGLE_STRIP);
    

    Entity* entity = world->createEntity();
    entity->setMesh (mesh);
    entity->setMaterial (mat);
    
}

void display ()
{

    world->startRendering();

    swap();

}

void destroy ()
{

    delete params;
    delete shaderProgram;

    delete mat;
    

    //delete camera    
    world->destroyCameras();

    //delete entity
    world->destroyEntities();

    delete world;

}

}}}



Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages